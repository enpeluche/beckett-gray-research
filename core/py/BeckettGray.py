import copy      # To create shallow and deep copies of objects
import timeit    # To measure the execution time of small code snippets
import math      # To access mathematical functions (pow, sqrt, ceil, etc.)
import cProfile  # To analyze performance and identify bottlenecks (profiling)
import time      # To handle time-related tasks (timestamps, delays)

def Binary(x, n):
    """
    Converts an integer into a binary representation as a list of bits.
    
    Args:
        x (int): The integer to convert.
        n (int): The desired length of the resulting list (padding with zeros).
        
    Returns:
        list: A list of n integers (0 or 1).
    """
    # Convert to binary string and remove the '0b' prefix
    binary_str = bin(x)[2:]
    
    # Convert the string characters into a list of integers
    bits = [int(bit) for bit in binary_str]
    
    # Pad with leading zeros to reach the required length 'n'
    return [0] * (n - len(bits)) + bits

def pw2(n):
    """
    Checks if a given integer is a power of two.
    
    Args:
        n (int): The number to check.
        
    Returns:
        bool: True if n is a power of two, False otherwise.
    """
    # A power of two has only one bit set to 1. 
    # n & (n-1) removes that bit; if the result is 0, it was a power of two.
    return n != 0 and (n & (n - 1)) == 0

def listepower2(n):
    """
    Generates a list of all powers of two up to 2^n (exclusive).
    
    Args:
        n (int): The exponent defining the upper bound range.
        
    Returns:
        list: All integers i < 2^n such that i is a power of two.
    """
    res = []
    # Iterate through the range [0, 2^n - 1]
    for i in range(2**n):
        # Use bitwise check to identify powers of two
        if pw2(i):
            res.append(i)
    return res

def listeBinaire(n):
    """
    Generates a list of all binary representations for integers from 0 to 2^n - 1.
    
    Args:
        n (int): The number of bits for each binary representation.
        
    Returns:
        list: A nested list where each element is a list of n bits.
    """
    res = []
    # Iterate through every possible value in the 2^n space
    for i in range(2**n):
        # Convert each integer to its fixed-length binary list
        res.append(Binary(i, n))
    return res

def listeFlip(n):
    """
    Computes a list of neighbors for each integer in the 2^n space.
    Each neighbor is generated by flipping exactly one bit (Hamming distance of 1).
    
    Args:
        n (int): The number of bits, defining the range [0, 2^n - 1].
        
    Returns:
        list: A 2D list where res[i] contains all values reachable from i by flipping one bit.
    """
    res = []
    # Iterate through all possible integers from 0 to 2^n - 1
    for i in range(2**n):
        res.append([])
        # Flip each of the n bits individually using XOR and bit shifting
        for j in range(n):
            # i ^ (1 << j) toggles the j-th bit of i
            res[i].append(i ^ (1 << j))
    return res

def listeUn1(n):
    """
    Creates a boolean mask for integers from 0 to 2^n - 1, 
    identifying numbers with exactly one bit set to 1.
    
    Args:
        n (int): The number of bits, defining the range [0, 2^n - 1].
        
    Returns:
        list: A list of booleans where res[i] is True if i has exactly one '1' in binary.
    """
    res = []
    # Iterate through the entire 2^n range
    for i in range(2**n):
        # Check if the binary representation contains exactly one set bit
        if bin(i).count('1') == 1:
            res.append(True)
        else:
            res.append(False)
    return res


def BGCHeuristique1(s,x,n,bgc,avail,old,oldS,listev,p2,bi,n2,flip,l11):
    """
    Recursive backtracking function with pruning to find Balanced Gray Codes.
    
    Args:
        s (int): Current step in the sequence construction.
        x (int): The last integer added to the sequence.
        n (int): Number of bits.
        bgc (list): The current sequence being built.
        avail (list): Boolean list tracking available (unvisited) integers.
        old, oldS (list): Tracking bit change positions and steps for balance constraints.
        listev (list): Degree of vertices (number of available neighbors).
        p2 (list): Precomputed powers of two.
        bi (list): Binary representations table.
        n2 (int): Total number of elements (2^n).
        flip (list): Precomputed neighbors for each integer.
        l11 (list): Boolean mask for powers of two.
    """

    global compteur
    compteur += 1
    
    # Base case: if the sequence length reaches 2^n, a valid BGC is found
    if s >= n2:
        listeCodeBGC.append(bgc.copy())
        return
    
    # Pruning: check if the balance constraint is violated
    if (s > 1 and s - oldS[0] > nbMax[n]):
        return
    
    # Check if we are at a power-of-two node and ensure future moves are possible
    if l11[x]:
        bool = False
        for i in p2:
            if avail[i]:
                bool = True
                break
        if not bool:
            return
        
    #if l11[x]:
    #    can_continue = any(avail[i] for i in p2)
    #    if not can_continue:
    #        return
        
    # Count available neighbors and identify forced moves (Hamiltonian path logic)
    cmpt = 0
    xn = 0
    b = 0
    for i in range(n):
        fxi = flip[x][i]
        if listev[fxi] == 1 and avail[fxi]:
            cmpt += 1
            if cmpt > 1: # More than one forced neighbor with degree 1: dead end
                return
            xn = fxi
            bit = n - i - 1

    # Case 1: A single neighbor with degree 1 is found (forced move)
    if cmpt == 1 and (bi[xn][bit] == 1 or bit == (old[0] if old else 0)):
        nold = old.copy()
        noldS = oldS.copy()

        # Update balance tracking lists
        if bi[xn][bit] == 1:
            nold.append(bit)
            noldS.append(s)
        else:
            nold.pop(0)
            noldS.pop(0)

        # Mark as visited and recurse
        avail[xn] = False
        bgc.append(xn)

        # Update degrees of neighbors for the next step
        res = listev.copy()
        for j in range(n):
            res[flip[xn][j]] -= 1
        BGCHeuristique1(s+1, xn, n, bgc, avail, nold, noldS, res, p2, bi, n2, flip, l11)

        # Backtrack: restore state
        avail[xn] = True
        bgc.pop()
        return
    
    # Case 2: No forced move, explore all available neighbors
    if cmpt == 0:
        for i in range(n):
            xn = flip[x][i]
            ni = n - i - 1
            if avail[xn] and (bi[xn][ni] == 1 or ni == (old[0] if old else 0)):
                nold = old.copy()
                noldS = oldS.copy()
                if bi[xn][ni] == 1:
                    nold.append(ni)
                    noldS.append(s)
                else:
                    nold.pop(0)
                    noldS.pop(0)

                avail[xn] = False
                bgc.append(xn)
                res = listev.copy()
                
                for j in range(n):
                    res[flip[xn][j]] -= 1
                
                BGCHeuristique1(s+1, xn, n, bgc, avail, nold, noldS, res, p2, bi, n2, flip, l11)

                # Backtrack: restore state
                avail[xn] = True
                bgc.pop()
        return
    else:
        return
    return

#def plusieurs1(m):
#    for i in range(m):
#        BGCHeuristique1(1,0,n,bgc,avail,[],lv,p22,bi,n2,F)

def plusieurs1(m):
    """
    Executes the BGC search multiple times.
    
    Args:
        m (int): The number of search iterations or starting attempts to perform.
    """
    for i in range(m):
        # Initialize the recursive search starting from step 1 and value 0
        # Passing initial states for constraints (empty lists/precomputed tables)
        BGCHeuristique1(1, 0, n, bgc, avail, [], [], lv, p22, bi, n2, F, l11)

# --- Global Configuration & Initialization ---
compteur = 0         # Counter to track the total number of recursive calls
n = 5                # Number of bits for the Gray Code
n2 = 2**n            # Total number of vertices in the n-dimensional hypercube
bgc = [0]            # List to store the current sequence, starting with 0
listeCodeBGC = []    # List to store all valid Balanced Gray Codes found

# --- Precomputations & Data Structures ---
# Track available (unvisited) nodes; 0 is marked False as it is the starting point
avail=[True for i in range(2**n)]
avail[0]=False

# Degree list: Number of available neighbors for each node (initially n)
lv=[n for i in range(2**n)]

p22 = listepower2(n)   # Precomputed powers of two
bi = listeBinaire(n)   # Binary representation lookup table
F = listeFlip(n)       # Adjacency list (neighbors differing by 1 bit)
l11 = listeUn1(n)      # Boolean mask for powers of two (nodes with weight 1)

# Balance constraints: Maximum allowed difference for bit transitions
nbMax = [0, 1, 2, 8, 16, 7, 10, 15, 13]

# Number of vertices at each Hamming weight (level) of the hypercube
listeNbSommet = [math.comb(n, k) for k in range(0, n + 1)]


# --- Execution & Benchmarking ---
# Measure execution time for one full search run
execution_time = timeit.timeit(
    'BGCHeuristique1(1,0,n,bgc,avail,[],[],lv,p22,bi,n2,F,l11)', 
    globals=globals(), 
    number=1
)
print(f"Execution Time: {execution_time} seconds")

# --- Results Output ---
print(f"Total Solutions Found: {len(listeCodeBGC)}")
print(f"Total Recursive Calls: {compteur}")


#t=time.time()
#cProfile.run('BGCHeuristique1(1,0,n,bgc,avail,[],lv,p22,bi,n2,F)')
#BGCHeuristique1(1,0,n,bgc,avail,[],lv,p22,bi,n2,F)